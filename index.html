<!DOCTYPE html> 
<html>
  <head>
    <script src='http://meeples.se/javascript/jspath-003.js' ></script>
    <script src='http://meeples.se/javascript/jslos_003.js' ></script>
    <script src='http://meeples.se/javascript/jsmatrix_008.js' ></script>
    <script src='http://meeples.se/javascript/jsmatrix-pathfinding_008.js' ></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script src="jaws.js"></script>
    <script src="rift.js"></script>
    <script src="spacebaserobots.js"></script>
    <script src="spacebasejobs.js"></script>
    <script src="spacebasemenu.js"></script>
    <script src="spacebasebuildings.js"></script>

    <link type="text/css" rel="stylesheet" href="style.css" />
    <title>Rift</title>
  </head>
<body>

  <canvas width=840 height=480 onclick="x();"></canvas>
  FPS: <span id="fps"></span>. Turn: <span id="turn">1</span>
  <button onclick="calculate_line_of_sight();">End Turn</button> 
  <div id="info">
    <h1>Rift</h1>
    Rift is a turn based party tactics game.<br>
    <br>
  </div>
  
  <h3>jaws log</h3>
  <div id="jaws-log"></div>
 
  <script>
    var directions = new Array();
    directions.push( {row: 0, col: -1 } );
    directions.push( {row: 0, col: 1 } );
    directions.push( {row: -1, col: 0 } );
    directions.push( {row: 1, col: 0 } );

    // The Javascript Matrix to Use
    jslos.blocker_values.push("0");
    
    function calculate_line_of_sight(){

        // Clear Fog Of War
        rift.blocker_tiles = new jaws.SpriteList();
        
        var m = exportTileMapToPathMatrix();

        jslos.reset_merged_tiles(rift.tile_map.size[1], rift.tile_map.size[0]);
        
        rift.workers.forEach(
            function( worker ){
                jslos.calculate_line_of_sight(m, worker.location(), 5);
            }
        );
    
		var losmatrix = jslos.merged_visible_tiles;
        
        for( row = 0; row < losmatrix.length; row++) {
            for( col = 0; col < losmatrix[row].length; col++) {
                if ( losmatrix[row][col] === jslos.BLOCKED ){
                    var x = col*rift.cell_size;
                    var y = row*rift.cell_size;
                    rift.blocker_tiles.push( new Sprite({image: "images/dark.png", x: x, y: y }) )
                }
            }
        }
    }
    
    function getAvailableWorker( goal ){
        var workers = rift.workers;
        var availableWorker;
        var steps;
        var shortest_path;

        workers.forEach(
            function( worker ){
                if( worker.state == rift.STATE_IDLE ){
                    if ( goal ){
                        var path = worker.find_path( goal );
                        if ( path.length > 0 && ( !steps || steps > path.length )){                
                            availableWorker = worker;
                            shortest_path = path;
                            steps = path.length;
                        }
                    } else {
                        availableWorker = worker;
                    }
                };
            }
        );

        return availableWorker;
    }

    function withinTileMap( col, row ){

        if ( col >= 0 && col < rift.tile_map.size[0] && row >= 0 && row < rift.tile_map.size[1] ){
            return true;
        } else {
            return false;
        }
    }

    function x(){

        // Get Coordinates
        var col = getTileNoFromCord(jaws.mouse_x);
        var row = getTileNoFromCord(jaws.mouse_y);

        // Create Job
        if ( withinTileMap(col, row)){
            // Check if there is a job at this place.
            var job = rift.tile_map.job(col, row);
            // Job exists on this place we remove it
            if ( job ){
                job.die();
            // Else we create one
            } else if ( rift.selection.item ){
                var job = rift.job(rift.selection.item.jobtype, rift.selection.item.target, col, row);
                // Add Job to jobs list
                if ( job.type.legal(job) ){
                    job.add();
                }
            }
        } else {
            // Check click for menu.
            rift.action_menu.select_item(jaws.mouse_x, jaws.mouse_y);
        }

    }

    function getTileNoFromCord(cord){
        return Math.floor(cord / rift.tile_map.cell_size[0]);
    }

    function exportTileMapToPathMatrix(){
        var cols = rift.tile_map.size[0]
        var rows = rift.tile_map.size[1]
        var matrix = jspath.create_matrix(rows,cols);
        var cell_size = rift.tile_map.cell_size[0];

        for( row = 0; row < matrix.length; row++) {
            for( col = 0; col < matrix[row].length; col++) {
                // Set it to walkable ( 1 ) by default
                matrix[row][col] = 1;            
                
                if ( rift.tile_map.check(col,row, "blocking", true)) {
                    matrix[row][col] = 0;
                }
            }
        }
        return matrix;
    }

    function Main() {
      var fps

      rift.workers.push(new rift.robot(0,128))
      rift.action_menu = rift.menu(641, 0);

      /* Called once when a game state is activated. Use it for one-time setup code. */
      this.setup = function() {
        fps = document.getElementById("fps")
        
    var tilemap_width = 20;
    var tilemap_height = 15;
    rift.cell_size = 32;

    // Get some Random terrain
    for ( var j = 0; j < tilemap_height; j++){
        for ( var i = 0; i <tilemap_width; i++){
            var x = i*rift.cell_size;
            var y = j*rift.cell_size;

            if ( Math.floor((Math.random()*10)+1) > 8 && x != 0 ){
                    rift.blocks.push( new Sprite({image: "images/block.png", x: x, y: y, blocking: true }) )
            } else {
                rift.blocks.push( new Sprite({image: "images/dirt.png", x: x, y: y, blocking: false}) )
            }
        }
    }

    rift.action_menu.add( new Sprite({image: "images/button_floor.png" }), rift.JOB_BUILD, "floor");
    rift.action_menu.add( new Sprite({image: "images/button_wall.png" }), rift.JOB_BUILD, "wall");
    rift.action_menu.add( new Sprite({image: "images/button_solarpanel.png" }), rift.JOB_BUILD, "solarpanel");
    rift.action_menu.add( new Sprite({image: "images/button_end_turn.png" }), rift.END_TURN, "end_turn");

        // A tilemap, each cell is 32x32 pixels. There's 10 such cells across and 10 downwards.
        rift.tile_map = new jaws.TileMap({size: [tilemap_width,tilemap_height], cell_size: [32,32], scale: 0.5})

    // Extending Tilemap
    rift.tile_map.check = function(col, row, option, value){
        var checked_value = false;
        this.cell(col,row).forEach(function(item){
            if ( item.options[option] == value){
                checked_value = true;
            }
        });
        return checked_value;
    }

    // Extending Tilemap
    rift.tile_map.job = function(col, row){
        var found_job;
        rift.jobs.forEach(function(item){
            if ( item.col == col && item.row == row ){
                found_job = item;
            }
        });
        return found_job;
    }

    rift.tile_map.find_free_neighbour = function(col, row){
        var y;
        $.each(directions, function(){
                var xrow = row + this.row;
                var xcol = col + this.col;
                if ( xcol >= 0 && xrow >= 0 && rift.tile_map.check(xcol, xrow, "blocking", false) ){
                    y = {row:xrow, col:xcol}
                }
            });
        return y;
    }

        // Fit all items in array blocks into correct cells in the tilemap
        // Later on we can look them up really fast (see player.move)
        rift.tile_map.push(rift.blocks)

        jaws.context.mozImageSmoothingEnabled = false;  // non-blurry, blocky retro scaling
        jaws.preventDefaultKeys(["up", "down", "left", "right", "space"])

    // For Debugging
    jaws.on_keydown("r", function(){rift.workers.push(new rift.robot(0,0))})
    jaws.on_keydown("e", function(){rift.units.push(new rift.enemy(0,0))})
      }

      /* update() will get called each game tick with your specified FPS. Put game logic here. */
      this.update = function() {

    rift.workers.forEach(function(worker){
        worker.act();
    });

    rift.units.forEach(function(unit){
        unit.act();
    });

    rift.jobs.forEach(function(job){
        // Start job
        if ( job.started == false ) {
            // Only look at the jobs if there are at least one available worker
            if ( getAvailableWorker() != undefined ){
                job.start();
            }
        }
    });



        //jaws.forceInsideCanvas(player)
        fps.innerHTML = jaws.game_loop.fps
      }

      /* Directly after each update draw() will be called. Put all your on-screen operations here. */
      this.draw = function() {
        jaws.clear()
        rift.blocks.draw()
    rift.buildings.draw()
    rift.jobs.draw()
    rift.bars.draw()
        rift.workers.draw()
    rift.units.draw()
    rift.action_menu.draw()
    rift.blocker_tiles.draw()

        if ( rift.selection.item != undefined ){
            rift.selection.draw();
        }

    }
    }
    
    jaws.onload = function() {
        jaws.unpack()
        jaws.assets.add([
            "images/droid_22x30.png",
            "images/block.png",
            "images/dirt.png",
            "images/job_default.png",
            "images/building_wall.png",
            "images/building_floor.png",
            "images/button_wall.png",
            "images/button_floor.png",
            "images/button__selector.png",
            "images/button_solarpanel.png",
            "images/building_solarpanel.png",
            "images/enemy_ball.png",
            "images/missile_plasma.png",
            "images/health_bar.png",
            "images/dark.png",
            "images/button_end_turn.png"
        ])
        jaws.start(Main)  // Our convenience function jaws.start() will load assets, call setup and loop update/draw in 60 FPS
    }
</script>

</body>
</html>

